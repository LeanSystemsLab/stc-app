# Architecture of STC-app

This document captures the architecture of the Smart Trash Can Application (STC-app), using the arc42 template.

# Introduction and Goals

This app helps people to put their trash into the right bin, by analyzing the trash with their smartphone camera.

## Requirements Overview

> ğŸ’¡ **Requirements IDs** can be generated by some tools, and indeed we do that with the other case studies. In this project, we create them by hand, because we are pragmatic, not religious.


Essential Features

* **R-01**: Classify trash correctly with smartphone camera
* **R-02**:Identify the correct bin for the identified trash, based on regional laws

Optional Features

* **R-03**: Generate printable labels with QR-Codes that the user can fix to a trash area, to allow app to identify it.
* **R-04**: Order replacement trash bags via the app.

## Quality Goals

  Quality Goal | Reason
--- | ---
**R-06**: Code and documentation follows best practices, no shortcuts. | Main purpose of this project is the book, not the trash
**R-07**: App works directly after installation. | Low-friction user experience
**R-08**: Number of uses is limited, until the user either pays or provides an AI API code. | We need some kind of cost control, and do not want to use ads to finance the app.

## Stakeholders

Role/Name   | Contact        | Expectations
---|---|---
Person with trash | | Low-friction help for recycling trash correctly.
Reader | | Concepts in the book become more understandable by a working example.
| Book author | Michael | Creating this product leads to better and more consistent content of the *Product Velocity* book.

# Architecture Constraints

* Works on all smartphones.
* Requires user to provide their own GPT API code.

# Context and Scope

## Business Context

**\<Diagram or Table>**

**\<optionally: Explanation of external domain interfaces>**

## Technical Context

**\<Diagram or Table>**

**\<optionally: Explanation of technical interfaces>**

**\<Mapping Input/Output to Channels>**

# Solution Strategy

> ğŸ’¡ **C4 Model** We want to use a C4 model for our architecture. However, gitHub rendering (mermaid) has only limited C4 support. We have to make a trade-off between (1) pretty rendering, but not having a single source, (2) ugly rendering and single source, or (3) pretty rendering, but not being 100% C4-compliant. This is option (3).

### System Context

The C4 System Context diagram visualizes everything our system (the STC) is interacting with. It defines the system's scope by showing who uses it, what external services it depends on, and how it fits into the broader environment. This helps establish clear boundaries and shared understanding early in the design process. Note that you can form sentences by following the arrows:

```
User â†’ physically disposes trash into â†’ bins
```


```mermaid
flowchart TD
    %% Nodes
    user(["ğŸ‘¤ User<br/><small>A person with trash in front of recycling bins</small>"])
    oauth(["OAuth Provider<br/><small>Authenticates users</small>"])
    stc["Smart Trash Can (STC)<br/><small>STC App on Smartphone</small>"]
    bins(["Bins<br/><small>Recycling bins (region-specific) for various classes of trash</small>"])
    server(["AI API Server<br/><small>External classification service</small>"])

    %% Edges
    user -->| classifies trash via smartphone camera using | stc
    stc -->|requests classification of trash image using | server
    user -->|physically disposes trash into | bins
    stc -->|suggests the correct bin from | bins
    stc -->|requests user authentication from | oauth
```

### Container View

The C4 Container diagram zooms into the STC system to show its internal structure. It illustrates the major building blocksâ€”called containersâ€”such as the web app, backend server, and database, and explains how they interact. This level of detail clarifies how responsibilities are split across components and how data flows through the system. 

We add additional technical information. In addition to the verbal description, for Containers we add types and technologies (e.g. MongoDB), and for relationships we add protocols (e.g. JSON/HTTPS).


```mermaid
flowchart TD
    %% External Actors
    user(["ğŸ‘¤ User<br/><small>ã€Personã€‘<br/>Interacts with the client app</small>"])
    trash(["Trash<br/><small>ã€Physical Itemã€‘<br/>Unsorted Trash</small>"])
    oauth(["OAuth Provider<br/><small>ã€Cloud Serviceã€‘<br/>Auth0 used for user authentication</small>"])
    serverAI(["AI Server<br/><small>ã€Cloud Serviceã€‘<br/>GPT API used for trash classification</small>"])

    %% Internal Containers
    client["Single-Page Web App<br/><small>ã€Typescript and vue/vuetifyã€‘<br/>Web app used by the user</small>"]
    db["ğŸ›¢ï¸ Database<br/><small>ã€MongoDBã€‘<br/>Stores user information.</small>"]

    backend["Backend Server<br/><small>ã€Typescript and nodeã€‘<br/>Handles logic, bin suggestion, authentication, API access</small>"]
    
    %% Grouping: STC
    subgraph STC
        client
        backend
        db
    end

    %% Relationships
    user --> | uses web app<br/><small>ã€HTTPSã€‘</small>| client
    client --> | makes API calls to<br/><small>ã€JSON/HTTPSã€‘</small>| backend
    trash --> | captured with camera<br/><small>ã€WebRTC APIã€‘</small> |client
    backend --> | reads from and writes to<br/><small>ã€MongoDB protocolã€‘</small> | db
    backend ---> | makes API calls to<br/><small>ã€JSON/HTTPSã€‘</small> | serverAI
    backend ---> | makes API calls to<br/><small>ã€JSON/HTTPSã€‘</small> | oauth
```

# Building Block View

## Whitebox Overall System

***\<Overview Diagram>***

Motivation  
*\<text explanation>*

Contained Building Blocks  
*\<Description of contained building block (black boxes)>*

Important Interfaces  
*\<Description of important interfaces>*

### \<Name black box 1>

*\<Purpose/Responsibility>*

*\<Interface(s)>*

*\<(Optional) Quality/Performance Characteristics>*

*\<(Optional) Directory/File Location>*

*\<(Optional) Fulfilled Requirements>*

*\<(optional) Open Issues/Problems/Risks>*

### \<Name black box 2>

*\<black box template>*

### \<Name black box n>

*\<black box template>*

### \<Name interface 1>

â€¦

### \<Name interface m>

## Level 2

### White Box *\<building block 1>*

*\<white box template>*

### White Box *\<building block 2>*

*\<white box template>*

â€¦

### White Box *\<building block m>*

*\<white box template>*

## Level 3

### White Box \<\_building block x.1\_\>

*\<white box template>*

### White Box \<\_building block x.2\_\>

*\<white box template>*

### White Box \<\_building block y.1\_\>

*\<white box template>*

# Runtime View

## \<Runtime Scenario 1>

-   *\<insert runtime diagram or textual description of the scenario>*

-   *\<insert description of the notable aspects of the interactions
    between the building block instances depicted in this diagram.>*

## \<Runtime Scenario 2>

## â€¦

## \<Runtime Scenario n>

# Deployment View

## Infrastructure Level 1

***\<Overview Diagram>***

Motivation  
*\<explanation in text form>*

Quality and/or Performance Features  
*\<explanation in text form>*

Mapping of Building Blocks to Infrastructure  
*\<description of the mapping>*

## Infrastructure Level 2

### *\<Infrastructure Element 1>*

*\<diagram + explanation>*

### *\<Infrastructure Element 2>*

*\<diagram + explanation>*

â€¦

### *\<Infrastructure Element n>*

*\<diagram + explanation>*

# Cross-cutting Concepts

## *\<Concept 1>*

*\<explanation>*

## *\<Concept 2>*

*\<explanation>*

â€¦

## *\<Concept n>*

*\<explanation>*

# Architecture Decisions

# Quality Requirements

## Quality Tree

## Quality Scenarios

# Risks and Technical Debts

# Glossary

| Term        | Definition        |
|-------------|-------------------|
| *\<Term-1>* | *\<definition-1>* |
| *\<Term-2>* | *\<definition-2>* |
